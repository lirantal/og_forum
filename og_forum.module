<?php

// $Id$

/**
 * @file
 * Creates a forum per organic group and restricts viewing forum nodes by group membership.
 */

/*
 * TODO:
 * - Support for multiple forums per group
 * - Support for both public and private forums
 */

/**
 * Implementation of hook_help().
 */
function og_forum_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Ties forums to organic groups.');
  }
}

/**
 * Implementation of hook_menu().
 */
function og_forum_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $items[] = array(
      'path' => 'og_forum',
      'callback' => 'og_forum_page',
      'type' => MENU_CALLBACK,
      'access' => user_access('access content'),
    );
  }

  return $items;
}

/**
 * Menu callback; allows us to set group context prior to
 * loading a forum
 */
function og_forum_page($forum) {
  $gid = $_GET['edit']['og_groups'][0];
  $group = node_load($gid);
  og_set_group_context($group);
  return forum_page($forum);
}

/**
 * Implementation of hook_settings().
 */
function og_forum_settings() {
  $form['#submit']['og_forum_settings_submit'] = array(); // custom submit handler
  $form['#submit']['system_settings_form_submit'] = array(); // form.inc never calls the $callback if a submit handler is defined

  $form['update'] = array(
    '#type' => 'fieldset',
    '#title' => t('Retroactively update old groups'),
    '#description' => t('Pressing this button will create forums for any groups that do not already have them.'),
    '#collapsible' => TRUE,
  );
  $form['update']['button'] = array(
    '#type' => 'submit',
    '#value' => t('Update old groups'),
  );
  return $form;
}

/**
 * Custom submit handler for group update
 */
function og_forum_settings_submit($form_id, $form_values) {
  if ($_POST['op'] == t('Update old groups')) {
    og_forum_retroactively_apply();
  }
}

/**
 * Implementation of hook_db_rewrite_sql().
 *
 * Restricts forum viewing by organic group.
 */
function og_forum_db_rewrite_sql($query, $primary_table = 'n', $primary_field = 'nid') {
  global $user;

  if ($primary_field == 'tid') {

    // Only do this on forum nodes
    if (arg(0) == 'forum' || db_result(db_query('SELECT type FROM {node} WHERE nid = %d', arg(1))) == 'forum') {
      $restrict = TRUE;
    }
    else if (arg(0) == 'node' && arg(1) == 'add' && arg(2) == 'forum') {
      $restrict = TRUE;
    }

    // If on a forum node, prevent display of all forums; only the ones for this organic group
    // The forum vocab should have a lower weight than any other vocabulary assigned to forum nodes.
    static $og_vocab = FALSE;
    if ($restrict) {
      $return['join'] = "INNER JOIN {og_term} ogt ON $primary_table.tid = ogt.tid LEFT JOIN {og_uid} ogu ON ogt.nid = ogu.nid AND ogu.uid = $user->uid";
      $return['where'] = '1=1';
      if (arg(0) == 'node' && arg(1) == 'add' && arg(2) == 'forum') {
        $og_nid = intval($_GET['edit']['og_groups'][0]);
        if ($og_nid && !$og_vocab) {
          $og_vocab = TRUE;
          $return['where'] = "ogt.nid = $og_nid";
        }
      }
      $return['distinct'] = TRUE;
      return $return;
    }
    else {
      return NULL;
    }

  }
}

/**
 * Implementation of hook_nodeapi().
 *
 * Automatically creates a forum container and forum each time an organic group is added.
 */
function og_forum_nodeapi($node, $op, $teaser = NULL) {
  switch ($op) {
    case 'prepare':
      if (arg(0) == 'node' && arg(1) == 'add' && arg(2) == 'forum') {
        if (!isset($_GET['edit']['og_groups'][0])) {
          return FALSE;
        }
      }
      break;
    case 'insert':
      if (og_is_group_type($node->type)) {
        $edit = array('name' => $node->title, 'vid' => _forum_get_vid());
        $status = taxonomy_save_term($edit);
        $containers = variable_get('forum_containers', array());
        $containers[] = $edit['tid'];
        variable_set('forum_containers', $containers);
        db_query('INSERT INTO {og_term} (tid, nid) VALUES (%d, %d)', $edit['tid'], $node->nid);

        $edit['name'] = t('Generic discussion');
        $edit['parent'] = array($edit['tid']);
        unset($edit['tid']);
        $status = taxonomy_save_term($edit);
        db_query('INSERT INTO {og_term} (tid, nid) VALUES (%d, %d)', $edit['tid'], $node->nid);
      }
      break;
    case 'delete':
      // Delete existing terms for this og
      if (og_is_group_type($node->type)) {
        $result = db_query('SELECT tid FROM {og_term} WHERE nid = %d', $node->nid);
        while ($term = db_fetch_object($result)) {
          taxonomy_del_term($term->tid);
        }
        db_query('DELETE FROM {og_term} WHERE nid = %d', $node->nid);
      }
      break;
  }
}

/**
 * Retrieve forum for given group
 *
 * @param $group_id
 *   Organic group ID
 * @return
 *   Forum's term ID
 */
function og_forum_get_forum($group_id) {
  // Grab most recent term created for group; this will be the forum as
  // opposed to the forum container.
  return db_result(db_query_range('SELECT tid FROM {og_term} WHERE nid = %d ORDER BY tid DESC', $group_id, 0, 1));
}

/**
 * Retrieve container for given group
 *
 * @param $group_id
 *   Organic group ID
 * @return
 *   Forum container's term ID
 */
function og_forum_get_forum_container($group_id) {
  // Grab most first term created for group; this will be the forum container
  return db_result(db_query_range('SELECT tid FROM {og_term} WHERE nid = %d ORDER BY tid ASC', $group_id, 0, 1));
}

/**
 * Implementation of hook_og_create_links().
 */
function og_forum_og_create_links($group) {
  $links = array();

  // Get group's forum
  $forum  = og_forum_get_forum($group->nid);
  if ($forum) {
    $links[] = l(t('view forum'), "og_forum/$forum/$group->nid", array('title' => t('View forum discussions.')), "edit[og_groups][]=$group->nid");
  }

  return $links;
}

/**
 * Creates forums for all groups that don't have any yet.
 */
function og_forum_retroactively_apply() {
  $counter = 0;
  // Obtain list of all groups
  $result = db_query('SELECT og.nid, n.title, n.type FROM {og} og INNER JOIN {node} n on og.nid = n.nid');
  while ($group = db_fetch_object($result)) {
    // See if terms are found for this group
    if (!db_result(db_query('SELECT * FROM {og_term} ogt WHERE ogt.nid = %d', $group->nid))) {
      // If so, fake a nodeapi insert
      og_forum_nodeapi($group, 'insert');
      $counter++;
    }
  }
  drupal_set_message(t('%num groups had forums created', array('%num' => $counter)));
}

/**
 * Implementation of hook_form_alter().
 */
function og_forum_form_alter($form_id, &$form) {
  // Auto-select group's forum when adding/editing a forum topic
  if ($form_id == 'forum_node_form') {
    $group = og_get_group_context();
    $term = og_forum_get_forum();
    if ($group->nid) {
      $vid =  _forum_get_vid();
      $form['taxonomy'][$vid]['#default_value'] = $term;
    }
  }

  // Dependency checker
  if ($form_id == 'system_modules' && !$_POST) {
    og_forum_system_module_validate($form);
  }
}

/**
 * Validates module dependencies for the module.
 */
function og_forum_system_module_validate(&$form) {
  $module = 'og_forum';
  $dependencies = array('og', 'forum', 'taxonomy', 'comment');

  foreach ($dependencies as $dependency) {
      if (!in_array($dependency, $form['status']['#default_value'])) {
        $missing_dependency = TRUE;
        $missing_dependency_list[] = $dependency;
      }
  }

  if (in_array($module, $form['status']['#default_value']) && isset($missing_dependency)) {
    db_query("UPDATE {system} SET status = 0 WHERE type = 'module' AND name = '%s'", $module);
    $key = array_search($module, $form['status']['#default_value']);
    unset($form['status']['#default_value'][$key]);
    drupal_set_message(t('The module %module was deactivated--it requires the following disabled/non-existant modules to function properly: %dependencies', array('%module' => $module, '%dependencies' => implode(', ', $missing_dependency_list))), 'error');
  }
}
